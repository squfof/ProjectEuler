/* 
 * File:    pe012.c
 * Author:  Jason Gower
 * Created: July 17, 2017, 10:00 PM
 * 
 * Problem: The sequence of triangle numbers is generated by adding the natural
 *          numbers.
 *          So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 *          The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * 
 *          Let us list the factors of the first seven triangle numbers:
 *          1: 1
 *          3: 1,3
 *          6: 1,2,3,6
 *          10: 1,2,5,10
 *          15: 1,3,5,15
 *          21: 1,3,7,21
 *          28: 1,2,4,7,14,28
 *          We can see that 28 is the first triangle number to have over five divisors.
 * 
 *          What is the value of the first triangle number to have over five hundred
 *          divisors?     
 */

#include <stdio.h>
#include <stdlib.h>

#define MIN 500L

int main(void)
{
    long triangular_number(long);
    long divisor_function(long);
    
    long n = 1;     // index of current triangular number
    long t = 1;     // current triangular number
    long d = 1;     // number of divisors of t
    
    // compute triangular numbers using Gauss' formula, then compute the value
    // of the divisor function from number theory with this input. stop when we
    // have enough divisors
    while (d <= MIN)
    {
        t = triangular_number(++n);
        d = divisor_function(t);
    }
    
    printf("T_%li = %li has %li (> %li) divisors.", n, t, d, MIN);
    
    return EXIT_SUCCESS;
}

// use Gauss' formula
long triangular_number(long n)
{
    return n * (n + 1) / 2;
}

// brute-force
int isPrime(long n)
{
    if (n == 2)
        return 1;
    else if (n % 2 == 0)
        return 0;
    
    for (long i = 3 ; i * i <= n ; i += 2)
        if (n % i == 0)
            return 0;
    
    return 1;
}

// brute-force
long smallestPrime(long n)
{
    int isPrime(long);
    
    if (n % 2 == 0)
        return 2;
    
    for (long i = 3 ; i * i <= n ; i += 2)
        if (isPrime(i) && n % i == 0)
            return i;
    
    return n;
}

// find powers e_i of primes p_i in n, then return product of (e_i + 1) over i
long divisor_function(long n)
{
    long smallestPrime(long);
    
    long d = 1;     // initialize return value
    long p;         // prime under current consideration
    long e;         // exponent of p in n
    long temp;      // used to find e
    long q = 1;     // product of primes seen so far
    long i;         // index
    
    // continue until q equals n
    while (q < n)
    {
        // get smallest prime that divides cofactor of q in n
        p = smallestPrime(n / q);
        
        // find exponent of p in n
        e = 1;
        temp = p * p;
        while (n % temp == 0)
        {
            e++;
            temp *= p;
        }
        
        // update d and q
        d *= e + 1;
        for (i = 0 ; i < e ; i++)
            q *= p;
    }
    
    return d;
}
